# README

![React: Principios](https://i.imgur.com/KpuNcbY.png)

### Notas relacionadas

#### `react`

* [**Conceptos BÃ¡sicos**](https://github.com/undefinedschool/notes-react-basics)
* [**Redux**](https://github.com/undefinedschool/notes-redux)

### Contenido

* [QuÃ© problema resuelve React?](https://github.com/undefinedschool/notes-react#qu%C3%A9-problema-resuelve-react)
* [Principios](https://github.com/undefinedschool/notes-react#principios)
  * [Declarativo](https://github.com/undefinedschool/notes-react#declarativo)
  * [Arquitectura basada en _componentes_](https://github.com/undefinedschool/notes-react#arquitectura-basada-en-componentes)
    * [Componente](https://github.com/undefinedschool/notes-react#componente)
  * [Flujo de datos unidireccional \(one-way data flow\)](https://github.com/undefinedschool/notes-react#flujo-de-datos-unidireccional-one-way-data-flow)
  * [Virtual DOM](https://github.com/undefinedschool/notes-react#virtual-dom)
  * [SÃ³lo se encarga de la UI](https://github.com/undefinedschool/notes-react#s%C3%B3lo-se-encarga-de-la-ui)
* [Nuestra tarea como React devs](https://github.com/undefinedschool/notes-react#nuestra-tarea-como-react-devs)

### QuÃ© problema resuelve React?

Antes de empezar a hablar sobre los diferentes conceptos, siempre es Ãºtil entender un poco la motivaciÃ³n, por quÃ© existe, quÃ© problema resuelve la herramienta que elegimos. En mi opiniÃ³n, este proceso resulta ademÃ¡s muy beneficioso para entender, tanto mejor como mÃ¡s rÃ¡pido, los conceptos fundamentales detrÃ¡s de cualquier tecnologÃ­a que decidamos usar.

Con los aÃ±os, la complejidad de las aplicaciones web fue creciendo. Al principio, sÃ³lo tenÃ­amos archivos HTML, CSS y algo de JS para proveer un mÃ­nimo de interacciÃ³n con el DOM. El cÃ³digo JS que escribÃ­amos no era compatible con todos los browsers por default, por lo que habÃ­a que escribir diferentes versiones. _jQuery_ surge entonces como una soluciÃ³n a este problema, brindando una API unificada para escribir este cÃ³digo una vez y de forma mÃ¡s simple, garantizando compatibilidad con los diferentes browsers.

Pero la complejidad de las bases de cÃ³digo seguÃ­a aumentando y los programas eran cada vez mÃ¡s difÃ­ciles de mantener. El framework _AngularJS_ aparece en el 2010 y se posiciona rÃ¡pidamente como el nuevo standard para construir SPAs \(single-page applications\), aportando una estructura y el uso de ciertos patrones \(MVC\) para organizar mejor nuestras aplicaciones.

MÃ¡s aÃºn, en aplicaciones donde acciones en diferentes partes de la UI tenÃ­an efectos sobre otras[\[1\]](./#cite_note-1), los problemas seguÃ­an estando y nos encontrÃ¡bamos con aplicaciones escritas en _Angular_ donde era difÃ­cil entender el _flujo de los datos_ y quÃ© parte del cÃ³digo afectaba a cuÃ¡l otra.

Facebook tenÃ­a este problema muy presente, por lo que decidieron desarrollar una alternativa. [En el 2013, Facebook libera _React_](https://www.youtube.com/watch?v=GW0rj4sNH2w), _una biblioteca de JavaScript para construir interfaces de usuario_, segÃºn definen en el [sitio oficial](https://reactjs.org/).

[â†‘ Ir al inicio](https://github.com/undefinedschool/notes-react-principles#contenido)

### Principios

#### Declarativo

La manipulaciÃ³n del DOM es uno de los principales cuellos de botella en la performance del front-end. React decide entonces tomar un enfoque mÃ¡s _declarativo_ y busca evitar que el browser estÃ© continuamente realizando operaciones costosas.

Por lo tanto, sÃ³lo vamos a encargarnos de diseÃ±ar las _vistas_ para cada _estado_ de nuestra aplicaciÃ³n y **React va a actualizar y renderizar de manera eficiente los componentes correctos cuando los datos cambien** \(estado\), haciendo cambios mÃ­nimos en el DOM. **El cÃ³digo declarativo es mÃ¡s predecible y por lo tanto, mÃ¡s fÃ¡cil de de razonar y debuggear**.

> ðŸ‘‰ **La vista pasa a ser entonces una funciÃ³n del estado** de la aplicaciÃ³n, es decir, cuando el estado de la aplicaciÃ³n cambia, la vista se vuelve a renderizar. Por lo tanto, **si queremos que la vista \(UI\) sea actualice, tenemos que modificar el estado de alguna forma**.

Ya no necesitamos preocuparnos por cÃ³mo manipular el DOM o manejar eventos del mismo, React se va a encargar de abstraernos de estos detalles.

[â†‘ Ir al inicio](https://github.com/undefinedschool/notes-react-principles#contenido)

#### Arquitectura basada en _componentes_

Vamos a construir interfaces de usuario \(UI\) utilizando _componentes reutilizables_, que poseen y manejan un _estado_ propio. Usamos estos _componentes_ como si fueran bloques de Lego, para construir componentes mÃ¡s complejos y eventualmente una aplicaciÃ³n entera.

> ðŸ‘‰ **Llamamos** _**estado**_ **a las caracterÃ­sticas propias de un componente**. Por ejemplo, cuando tenemos un componente que hace requests a un server, puede tener dos estados posibles, pendiente o finalizado.

La lÃ³gica de los componentes se escribe en JavaScript \(y no utilizando _templates_, como es el caso de otras libs/frameworks de front\), por lo que podemos pasar datos \(_props_\) de forma simple y mantener el estado fuera del DOM.

[â†‘ Ir al inicio](https://github.com/undefinedschool/notes-react-principles#contenido)

**Componente**

> ðŸ‘‰ **Un componente es un** _**bloque de cÃ³digo reutilizable**_**, una pieza de UI con contenido, estilos y comportamiento definidos: contiene todo el HTML, CSS y JS necesario para funcionar**.

Por ejemplo, una barra de bÃºsqueda es un componente, porque tiene una funciÃ³n independiente, una botÃ³n podrÃ­a tambiÃ©n a ser un componente, porque cumple una funciÃ³n. BÃ¡sicamente, cualquier secciÃ³n de la UI puede llegar a ser un componente.

Por lo tanto, **en React, cada parte de la UI es un componente y cada componente tiene un estado**.

Si el _estado_ de nuestra aplicaciÃ³n indica por ejemplo, que un usuario se encuentra logueado, crearemos los componentes correspondientes basados en esa informaciÃ³n.

> ðŸ‘‰ **Los componentes entonces, no dejan de ser simples funciones de JavaScript** que reciben esta informaciÃ³n a travÃ©s de diferentes parÃ¡metros a los que llamaremos _props_ \(por _propiedades_\) y retornan el cÃ³digo necesario \(usando [_JSX_](https://reactjs.org/docs/introducing-jsx.html)\) para renderizar los componentes. **Las props son** _**inmutables**_ **y siempre se pasan de componentes superiores a componentes inferiores**.

[â†‘ Ir al inicio](https://github.com/undefinedschool/notes-react-principles#contenido)

#### Flujo de datos unidireccional \(_one-way data flow_\)

> ðŸ‘‰ En React, **los datos tienen 1 y sÃ³lo 1 forma \(o direcciÃ³n\) de ser transferidos hacia otras partes de la aplicaciÃ³n**. Esto implica que los _componentes hijos_ \(child components\) no pueden actualizar los datos que provienen de un _componente padre_ \(parent component\).

![one-way data flow](https://image.slidesharecdn.com/wjkqukgsqgm2vger5dnt-signature-2cf736e9b897e2aaaa6315f9d31d6951ba19fae7560fe278cefb4644ac0753c6-poli-170428114140/95/ndc17-unrealjs-ue4-35-638.jpg?cb=1493434725)

**Los datos que vienen de un** _**componente padre**_ **se conocen como** _**props**_.

El principal beneficio de tomar este approach, en el que los datos _fluyen_ a travÃ©s de nuestra aplicaciÃ³n en una Ãºnica direcciÃ³n, es que el cÃ³digo resulta mÃ¡s fÃ¡cil de razonar y debuggear, porque sabemos quÃ© datos provienen de dÃ³nde y por lo tanto menos propenso a errores.

> ðŸ‘‰ Cualquier cambio que se le realice al _state_ de un componente, sÃ³lo puede afectar a los componentes que estÃ¡n _debajo_ \(los _child components_\), que van a recibirlo como _props_ de sÃ³lo lectura.

**Como los datos se mueven en una Ãºnica direcciÃ³n, modificar el estado de un componente no afecta a su componentes padre o hermanos: sÃ³lo los descendientes van a ser afectados** \(un _child component_ no puede modificar el _state_ de su _parent component_\). Esta es la principal razÃ³n por la que [el _state_ suele _levantarse_](https://reactjs.org/docs/lifting-state-up.html) \(lo movemos "hacia arriba" en el _Ã¡rbol de componentes_\), de manera tal que pueda compartirse y ser accedido entre los componentes que lo necesitan.

[â†‘ Ir al inicio](https://github.com/undefinedschool/notes-react-principles#contenido)

#### Virtual DOM

**Actualizar y volver a renderizar el DOM en el browser cada vez que queremos realizar un cambio en la UI tiene un gran impacto en la performance de nuestra aplicaciÃ³n**, porque implica realizar operaciones costosas. Al hacer cambios en el DOM, el elemento modificado y sus descendientes \(children\) deben volver a renderizarse para que el cambio se vea reflejado en la UI. Realizar estas operaciones continuamente \([_re-rendering_, _re-painting_, etc](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction)\) es lo que vuelven lenta y poco eficiente a esta forma de trabajar.

React propone utilizar una alternativa, el _Virtual DOM_.

> ðŸ‘‰ **El** [_**Virtual DOM**_](https://programmingwithmosh.com/react/react-virtual-dom-explained/) **es una representaciÃ³n virtual del DOM, una "versiÃ³n liviana" \(un gran objeto JS\) del DOM real que encontramos en el browser, que React utiliza para** _**mapear**_ **elementos del DOM real y poder realizar cambios en este de una forma mucho mÃ¡s rÃ¡pida y eficiente**. Cada vez que el _state_ de nuestra aplicaciÃ³n cambia, se actualiza el _Virtual DOM_ y no el DOM real.

![React Virtual DOM](https://miro.medium.com/max/2048/1*wrh_lW6mpQHRsuGtw1FuqA.png)

> ðŸ‘‰ BÃ¡sicamente, cada vez que agregamos nuevos elementos \(componentes\) a la UI, un nuevo _virtual DOM_ \(representado como un Ã¡rbol\) es creado. Cada elemento es un _nodo_ de este Ã¡rbol. React toma un _snapshot_ de los elementos de nuestra aplicaciÃ³n y lo carga en este Ã¡rbol. Si el _state_ de alguno de estos elementos cambia, se genera un nuevo _virtual DOM_. Este DOM \(virtual\) es entonces comparado con el DOM \(virtual\) previo y se calculan las diferencias a travÃ©s de un [_algoritmo de diffing_](https://medium.com/@gethylgeorge/how-virtual-dom-and-diffing-works-in-react-6fc805f9f84e). Utilizando esta informaciÃ³n, **React calcula la forma mÃ¡s eficiente de realizar los cambios en el DOM real**, actualizando sÃ³lo los nodos que cambiaron, reduciendo el impacto en la _performance_ de nuestra aplicaciÃ³n.

Otra estrategia que utiliza React para mejorar la performance es enviar los cambios detectados en el virtual DOM por _lotes_ \(batch\), para luego realizar los cambios necesarios en el DOM real de una vez, en lugar de estar enviando continuamente updates al mismo por cada cambio del estado.

> ðŸ‘‰ **En resumen:**
>
> * realizar updates frecuentes del DOM \(real\) es costoso y tiene un gran impacto en la performance
> * el _Virtual DOM_ es una representaciÃ³n virtual del DOM real que React utiliza para mejorar la performance
> * cuando ocurre un cambio en el _state_, se genera un nuevo _virtual DOM_ y se compara con la versiÃ³n anterior. Esto se conoce como _diffing_
> * los cambios a realizar en el DOM se envÃ­an por tandas, para actualizar la UI con menor frecuencia y por lo tanto, menor costo

[â†‘ Ir al inicio](https://github.com/undefinedschool/notes-react-principles#contenido)

#### SÃ³lo se encarga de la UI

> ðŸ‘‰ **React es una librerÃ­a \(o biblioteca\) que sÃ³lo se encarga de resolver un problema: renderizar la** _**vista**_ **o UI de nuestra aplicaciÃ³n**.

A diferencia de otros _frameworks_ de front-end, como Angular, Vue o Svelte, **React no es opinionado**, no asume nada sobre nuestro stack tecnolÃ³gico ni sobre cÃ³mo resolver y conectar el resto de las partes; esas decisiones quedarÃ¡n por nuestra cuenta. Gracias a esto, la _API_ de React resulta mÃ¡s concisa y simple en comparaciÃ³n y por lo tanto, mÃ¡s simple de aprender.

AdemÃ¡s, **esta caracterÃ­stica permite tambiÃ©n que podamos reutilizar cÃ³digo React en diferentes plataformas**: por ejemplo, renderizando desde el servidor usando [Node](https://nodejs.org/) o en aplicaciones mÃ³viles, a travÃ©s de [React Native](https://facebook.github.io/react-native/).

[â†‘ Ir al inicio](https://github.com/undefinedschool/notes-react-principles#contenido)

### Nuestra tarea como _React devs_

Como devs, tendremos que tomar varias decisiones relacionadas a la _arquitectura de la aplicaciÃ³n_, que podrÃ­an resumirse en los siguientes puntos:

* definir los _**React components**_
* definir quÃ© datos forman parte del _**state**_ y dÃ³nde \(en quÃ© componente\) va a vivir
* decidir **quÃ© cambios deben realizarse en la UI cuando el** _**state**_ **cambia**

[â†‘ Ir al inicio](https://github.com/undefinedschool/notes-react-principles#contenido)

[1](./#cite_ref-1) Estos problemas existieron \(y todavÃ­a existen\) en las librerÃ­as que decidieron usar [_**2-way data binding**_](https://medium.com/front-end-weekly/what-is-2-way-data-binding-44dd8082e48e) **\(o flujo de datos** _**bidireccional**_**\)**. Es decir, los cambios en la UI afectan al objeto JS que la UI quiere representar y viceversa.

